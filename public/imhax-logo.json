{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "gradient",
      "usesPingPong": false,
      "speed": 0.21,
      "trackMouse": 0,
      "mouseMomentum": 0,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0.9568627450980393, 0, 0.01568627450980392); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.9568627450980393, 0, 0.01568627450980392); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": { "downSample": 0.5, "depth": false, "uniforms": {}, "isBackground": true }
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 0.996031746031746,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "MULTIPLY",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "shape",
      "width": 0.45826120644598894,
      "widthMode": "relative",
      "height": 0.711754920922022,
      "heightMode": "auto",
      "left": 0.3159308726190329,
      "leftMode": "relative",
      "top": 0.4098367882621856,
      "topMode": "relative",
      "rotation": 0,
      "pos": { "type": "Vec2", "_x": 0.5, "_y": 0.5 },
      "borderRadius": 0,
      "gradientAngle": 0,
      "strokeWidth": 0,
      "coords": [
        [0, 0],
        [0.45826120644598894, 0],
        [0.45826120644598894, 0.711754920922022],
        [0, 0.711754920922022]
      ],
      "fill": ["#F50551"],
      "fitToCanvas": false,
      "gradientType": "linear",
      "type": "circle",
      "stroke": ["#000000"],
      "numSides": 3,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return src * dst; }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.0000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (0.0000 == 1.00) { if(0 == 2) { background *= (1. - color.a); color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(0 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture, vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 1.0000); } } fragColor = color; return; }if (3 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(3, unpremultColor, background.rgb); color = vec4(blendedColor, 1.0) * (color.a * 1.0000); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 1.0000); }fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} }
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 1.0793650793650795,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "shape",
      "width": 0.49660178547135064,
      "widthMode": "relative",
      "height": 0.7117549209220221,
      "heightMode": "auto",
      "left": 0.7031656922940699,
      "leftMode": "relative",
      "top": 0.6394977992924675,
      "topMode": "relative",
      "rotation": 0,
      "pos": { "type": "Vec2", "_x": 0.5, "_y": 0.5 },
      "borderRadius": 0,
      "gradientAngle": 0,
      "strokeWidth": 0,
      "coords": [
        [0, 0],
        [0.49660178547135064, 0],
        [0.49660178547135064, 0.7117549209220221],
        [0, 0.7117549209220221]
      ],
      "fill": ["#B3DA5D"],
      "fitToCanvas": false,
      "gradientType": "linear",
      "type": "circle",
      "stroke": ["#000000"],
      "numSides": 3,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} }
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 1.0793650793650795,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "shape",
      "width": 0.49660178547135064,
      "widthMode": "relative",
      "height": 0.7117549209220221,
      "heightMode": "auto",
      "left": 0.3550175441459218,
      "leftMode": "relative",
      "top": 0.6396576569756648,
      "topMode": "relative",
      "rotation": 0,
      "pos": { "type": "Vec2", "_x": 0.5, "_y": 0.5 },
      "borderRadius": 0,
      "gradientAngle": 0,
      "strokeWidth": 0,
      "coords": [
        [0, 0],
        [0.49660178547135064, 0],
        [0.49660178547135064, 0.7117549209220221],
        [0, 0.7117549209220221]
      ],
      "fill": ["#1DAB4F"],
      "fitToCanvas": false,
      "gradientType": "linear",
      "type": "circle",
      "stroke": ["#000000"],
      "numSides": 3,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} }
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 1.0158730158730158,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "MULTIPLY",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "shape",
      "width": 0.46738991573774175,
      "widthMode": "relative",
      "height": 0.7117549209220222,
      "heightMode": "auto",
      "left": 0.7457263018329404,
      "leftMode": "relative",
      "top": 0.5757566919333954,
      "topMode": "relative",
      "rotation": 0,
      "pos": { "type": "Vec2", "_x": 0.5, "_y": 0.5 },
      "borderRadius": 0,
      "gradientAngle": 0,
      "strokeWidth": 0,
      "coords": [
        [0, 0],
        [0.46738991573774175, 0],
        [0.46738991573774175, 0.7117549209220222],
        [0, 0.7117549209220222]
      ],
      "fill": ["#F53001"],
      "fitToCanvas": false,
      "gradientType": "linear",
      "type": "circle",
      "stroke": ["#000000"],
      "numSides": 3,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return src * dst; }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.0000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (0.0000 == 1.00) { if(0 == 2) { background *= (1. - color.a); color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(0 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture, vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 1.0000); } } fragColor = color; return; }if (3 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(3, unpremultColor, background.rgb); color = vec4(blendedColor, 1.0) * (color.a * 1.0000); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 1.0000); }fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} }
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 0.996031746031746,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "MULTIPLY",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "shape",
      "width": 0.45826120644598894,
      "widthMode": "relative",
      "height": 0.711754920922022,
      "heightMode": "auto",
      "left": 0.4983382800264403,
      "leftMode": "relative",
      "top": 0.38770528052328834,
      "topMode": "relative",
      "rotation": 0,
      "pos": { "type": "Vec2", "_x": 0.5, "_y": 0.5 },
      "borderRadius": 0,
      "gradientAngle": 0,
      "strokeWidth": 0,
      "coords": [
        [0, 0],
        [0.45826120644598894, 0],
        [0.45826120644598894, 0.711754920922022],
        [0, 0.711754920922022]
      ],
      "fill": ["#F40004"],
      "fitToCanvas": false,
      "gradientType": "linear",
      "type": "circle",
      "stroke": ["#000000"],
      "numSides": 3,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) { return src * dst; }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.0000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (0.0000 == 1.00) { if(0 == 2) { background *= (1. - color.a); color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(0 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture, vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 1.0000); } } fragColor = color; return; }if (3 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(3, unpremultColor, background.rgb); color = vec4(blendedColor, 1.0) * (color.a * 1.0000); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 1.0000); }fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} }
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "blur",
      "usesPingPong": false,
      "trackMouse": 0,
      "mouseMomentum": 0,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.; float amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000)); color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i); } return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 0 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.; float amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000)); color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i); } return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 1 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}",
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.; float amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000)); color += texture(tex, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i); } return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 2 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": {
        "downSample": 0.25,
        "depth": false,
        "uniforms": {},
        "isBackground": false,
        "passes": [
          { "prop": "vertical", "value": 1, "downSample": 0.25 },
          { "prop": "vertical", "value": 2, "downSample": 0.5 },
          { "prop": "vertical", "value": 3, "downSample": 0.5 }
        ]
      }
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 1,
      "layerName": "",
      "userDownsample": 1,
      "isElement": true,
      "opacity": 1,
      "effects": [],
      "displace": 0,
      "trackMouse": 0,
      "anchorPoint": "center",
      "mouseMomentum": 0,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0,
      "states": { "appear": [], "scroll": [], "hover": [] },
      "layerType": "image",
      "imageLoaded": false,
      "width": 540,
      "widthMode": "fixed",
      "height": 546.2234042553192,
      "heightMode": "fixed",
      "left": 0.5,
      "leftMode": "relative",
      "top": 0.5,
      "topMode": "relative",
      "rotation": 0,
      "fitToCanvas": 0,
      "src": "https://assets.unicorn.studio/images/RfUu3cIyg7PoPm9PSc2jlYbQBtS2/KG ILLOS.svg",
      "naturalWidth": 1128,
      "naturalHeight": 1141,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.0000);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} }
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "sdf_shape",
      "usesPingPong": false,
      "speed": 0.51,
      "trackMouseMove": 0,
      "mouseMomentum": 1,
      "trackMouse": 0.15,
      "animating": true,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize; float customTexAspect;const mat3 ROT_Y_90 = mat3( 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0 );const mat3 ROT_Z_90 = mat3( 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );const mat3 ROT_X_90 = mat3( 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 );mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }mat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, -s, s, c); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float smin(float a, float b, float k) { float h = max(k - abs(a - b), 0.0); return min(a, b) - h * h * 0.25 / k; }float sphere(vec3 p, float r) { return length(p) - r; }float sdfCylinder(vec3 p, float radius, float height) { vec2 d = abs(vec2(length(p.xz) - radius, p.y)) - vec2(radius, height * 0.5); return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)); }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }float mergedDiscs(vec3 p) { float result = sdfCylinder(p, 0.7, 0.01 + 0.2900 * 0.5);for(float i = 1.; i < 4.; i++) { float angle = (i * 45.)/360. * 2.0 * PI; mat2 rotZMat = rot(angle); vec3 rotatedP = vec3(rotZMat * p.xy, p.z);result = smin( result, sdfCylinder(rotatedP, 0.7, 0.01 + 0.2900 * 0.5), 0.2 ); }return max(result, sphere(p, 1.4)); }vec3 getRepeat(vec3 p) { float spacing = (0.5000 + 0.2600 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.5000 + 0.2600 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { float scale = max(0.5700, 0.000000001); float scaleFactor = 1.0/scale; vec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0.7, 0.82);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.2600 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.1500); vec2 axis = vec2(-1. * vec3(0.48503740648379057, 0.5187032418952618, 0.7317).y - 1. + mousePos.y/PI, vec3(0.48503740648379057, 0.5187032418952618, 0.7317).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 0.5, 0).x * baseTime; float timeY = vec3(0, 0.5, 0).y * baseTime; float timeZ = vec3(0, 0.5, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.48503740648379057, 0.5187032418952618, 0.7317).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return mergedDiscs(p); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float NdotV = abs(dot(eyeVector, worldNormal)); float width = fwidth(dot(eyeVector, worldNormal)); float threshold = 0.2; float edgeDampFactor = smoothstep(threshold, -threshold, width); float fresnelFactor = 1.0 - NdotV; return pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5); }vec3 noFrostOrDispersion(vec3 rd, vec3 normal) { float ior = 1.0 / (1.0 + 0.7000 * 0.25); vec3 refractedRay = refract(rd, normal, ior); return texture(uTexture, vTextureCoord - refractedRay.xy).rgb; }vec3 frostOrDispersion(vec3 rd, vec3 normal) { vec3 refractionColor = vec3(0); float iorBase = 1. + 0.7000 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.2500 * 1.2;for(float i = 0.; i < DISP_STEPS; i++) { float step = i / DISP_STEPS; vec3 disp = step * dispCoefficients; vec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r); vec3 refractedRayG = refract(rd, normal, ior.g); vec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r; refractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g; refractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b; }return clamp(refractionColor / DISP_STEPS, 0.0, 1.0); }vec3 calculateNormal(vec3 p, float eps) { vec2 e = vec2(eps, 0.0); vec3 normal = normalize(vec3( getMergedSDF(p + e.xyy) - getMergedSDF(p - e.xyy), getMergedSDF(p + e.yxy) - getMergedSDF(p - e.yxy), getMergedSDF(p + e.yyx) - getMergedSDF(p - e.yyx) )); return normal; }vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal); return noFrostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0.0000000001, getMergedSDF(p) - (0.2600 + 0.005)) * max(0.5700, 0.000000001); }const int STEPS = 128; const float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) { float pixelSize = 0.0025; float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0; float lastDistance = 0.0; float smoothing = mix(1., 4., 0.2000);for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); float progress = float(i)/float(STEPS); float step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) { partialAlpha = 1.; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, pixelSize * smoothing); break; }lastDistance = distance;traveled += max(step, pixelSize); if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return texture(uTexture, vTextureCoord); }vec4 bg = texture(uTexture, vTextureCoord);vec3 samplePosition = mix(rd, entryPoint, 0.0000); vec3 refractionColor = sampleTexture(samplePosition, entryNormal); vec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5), vec3(0.25, 0.25, -3).z); vec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir); vec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000); vec3 fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.0000 * vec3(1, 1, 1);vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.0000 + 0.01); vec3 specularEffect = specFactor * 0.0000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000); finalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor; }out vec4 fragColor;void main() { vec4 col = vec4(0);if(0.5700 <= 0.0001) { col = vec4(0); if(1 == 1) { col = texture(uTexture, vTextureCoord); } fragColor = col; return; }vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5); col = rayMarch(viewDir, rd); float dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false }
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "vignette",
      "usesPingPong": false,
      "trackMouse": 0,
      "mouseMomentum": 0,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.5000, 1.0 - 0.5000); float halfRadius = 0.2100 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.5, 0.5); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333), 1.0000), falloff); color = mix(color * (1.-falloff), vec4(finalColor * color.a, color.a), 1.0000); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false }
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "sphere",
      "usesPingPong": false,
      "trackMouse": 0,
      "mouseMomentum": 0,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;const float STEPS = 16.0; const float PI = 3.1415926;vec3 chromaticAbberation(vec2 st, float angle, float amount, float blend) { float aspectRatio = uResolution.x/uResolution.y; float rotation = angle * 360.0 * PI / 180.0; vec2 aberrated = amount * vec2(0.1 * sin(rotation) * aspectRatio, 0.1 * cos(rotation)); aberrated *= distance(st, vec2(0.5)) * 2.0; vec4 red = vec4(0); vec4 blue = vec4(0); vec4 green = vec4(0); float invSteps = 1.0 / STEPS; float invStepsHalf = invSteps * 0.5; for(float i = 1.0; i <= STEPS; i++) { vec2 offset = aberrated * (i * invSteps); red += texture(uTexture, st - offset) * invSteps; blue += texture(uTexture, st + offset) * invSteps; }for (float i = 0.0; i <= STEPS; i++) { vec2 offset = aberrated * ((i * invSteps) - 0.5); green += texture(uTexture, st + offset) * invSteps; } return vec3(red.r, green.g, blue.b); }vec2 sphericalTransformation( float u, float v, float uCenter, float vCenter, float lensRadius, float tau) { float aspectRatio = uResolution.x/uResolution.y; u -= uCenter; v -= vCenter;float s = sqrt(u * u + v * v); if (s > lensRadius) return vec2(u + uCenter, v + vCenter);float z = sqrt(lensRadius * lensRadius - s * s);float uAlpha = (1.0 - (1.0 / tau)) * asin(u / lensRadius); float vAlpha = (1.0 - (1.0 / tau)) * asin(v / lensRadius);u = uCenter + z * sin(uAlpha); v = vCenter + z * sin(vAlpha);return vec2(u/aspectRatio, v); }float circularIn(float t) { return 1.0 - sqrt(1.0 - t * t); }vec2 fisheyeTransformation( float u, float v, float uCenter, float vCenter, float lensRadius, float distortionScale ) { float aspectRatio = uResolution.x / uResolution.y;vec2 dir = vec2(u - uCenter, v - vCenter);dir.x /= lensRadius; dir.y /= lensRadius;float dist = length(dir) * 0.15;if (dist < 1.0) { float theta = atan(dir.y, dir.x);float r = dist * 2.0 * PI; float z = sqrt(1.0 - r * r) + 0.25; float rDist = atan(r, z) / PI; float newDist = mix(dist, rDist, 5.);dir.x = newDist * cos(theta); dir.y = newDist * sin(theta); }dir.x *= lensRadius; dir.y *= lensRadius;return mix(vec2(u/aspectRatio, v), vec2(uCenter/aspectRatio, vCenter) + dir, 1.0000); }vec2 discTransformation( float u, float v, float uCenter, float vCenter, float lensRadius, float distortionScale) { float aspectRatio = uResolution.x/uResolution.y; u -= uCenter; v -= vCenter;float s = sqrt(u * u + v * v); if (s > lensRadius) return vec2(u + uCenter, v + vCenter); float r = sqrt(u * u + v * v) / lensRadius; if(r == 0.0) return vec2(uCenter, vCenter);r = pow(r, distortionScale); float theta = atan(r); float rad = theta / r;u = rad * u + uCenter; v = rad * v + vCenter;return vec2(u/aspectRatio, v); }out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float aspectRatio = uResolution.x/uResolution.y; uv.x = uv.x * aspectRatio; vec2 sphereCoords = uv; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); pos.x *= aspectRatio;float radius = 0.5800 * uResolution.x/max(uResolution.x, uResolution.y);if(1 == 0) { sphereCoords = sphericalTransformation( mix(sphereCoords.x, 1.-sphereCoords.x, 0.0000), mix(sphereCoords.y, 1.-sphereCoords.y, 0.0000), mix(pos.x, 1.-pos.x, 0.0000), mix(pos.y, 1.-pos.y, 0.0000), radius/2., 1. + 1.0000 * 9. ); } else if(1 == 1) { sphereCoords = discTransformation( mix(sphereCoords.x, 1.-sphereCoords.x, 0.0000), mix(sphereCoords.y, 1.-sphereCoords.y, 0.0000), mix(pos.x, 1.-pos.x, 0.0000), mix(pos.y, 1.-pos.y, 0.0000), radius/2., 1. + 1.0000 * 9. ); } else if(1 == 2) { sphereCoords = fisheyeTransformation( mix(sphereCoords.x, 1.-sphereCoords.x, 0.0000), mix(sphereCoords.y, 1.-sphereCoords.y, 0.0000), mix(pos.x, 1.-pos.x, 0.0000), mix(pos.y, 1.-pos.y, 0.0000), radius/2., 1. + 1.0000 * 9. ); }vec2 scaledCoords = (sphereCoords - 0.5) + 0.5; vec4 sphere = texture(uTexture, clamp(scaledCoords, 0.0, 1.0)); float distFromPos = distance(uv, pos); float edgeSmooth = 0.001; float insideSphere = 1.0 - smoothstep(radius/2.0 - edgeSmooth, radius/2.0, distFromPos); float insideSphereAlpha = 1.0 - smoothstep(radius/2.0 + 0.002 - edgeSmooth, radius/2.0 + 0.002, distFromPos); sphere.rgb = chromaticAbberation(scaledCoords, atan(scaledCoords.y, scaledCoords.x), distFromPos * 0.8600, 1.0); color = mix(color, sphere, insideSphere); color.rgb += vec3((0.5000-0.5)*2.) * mix(0., circularIn(smoothstep(0., radius, distFromPos)), insideSphere); if(1 == 1) { color.a = insideSphereAlpha; color.rgb = mix(vec3(0), color.rgb, insideSphereAlpha); } fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false }
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "mouseDraw",
      "usesPingPong": true,
      "trackMouse": 0,
      "mouseMomentum": 0,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb); float angle = mouseTrail.x; float strength = mouseTrail.z * (0.5000 * 5.0);vec2 direction = angleToDir(angle);vec4 bg = texture(uTexture, uv - (direction * 0.1 * strength * 0.0000)); vec4 color = vec4(0,0,0,1);color.rgb = vec3(strength * mix(mouseRgb, vec3(0.9568627450980393, 0, 0.01568627450980392), 0.5000)); float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;if(1 > 0) { vec3 blendedRgb = blend(1, color.rgb + dither, bg.rgb); fragColor = vec4(mix(bg.rgb, blendedRgb, mouseTrail.z), 1.0); } else { fragColor = mix(bg, color, mouseTrail.z); } }",
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec2 liquify(vec2 st, vec2 dir) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; float amplitude = 0.0025; float freq = 6.; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * freq * st.y + uTime * 0.02 * dir.x), amplitude * sin(i * freq * st.x + uTime * 0.02 * dir.y) ); } st.x /= aspectRatio; return st; }vec3 calculateTrailContribution(vec2 mousePos, vec2 prevMousePos, vec2 uv, vec2 correctedUv, float aspectRatio, float radius) { vec2 dir = (mousePos - prevMousePos) * vec2(aspectRatio, 1.0); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI; vec2 mouseVec = mousePos - prevMousePos; float mouseLen = length(mouseVec); vec2 mouseDir = mouseLen > 0.0 ? mouseVec / mouseLen : vec2(0.0); vec2 posToUv = (correctedUv - prevMousePos) * vec2(aspectRatio, 1.0); float projection = clamp(dot(posToUv, mouseDir * vec2(aspectRatio, 1.0)), 0.0, mouseLen * aspectRatio); vec2 closestPoint = prevMousePos * vec2(aspectRatio, 1.0) + mouseDir * vec2(aspectRatio, 1.0) * projection; float distanceToLine = distance(correctedUv, closestPoint); float s = (1.0 + radius)/(distanceToLine + radius) * radius; vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 pointColor = hsv2rgb(color); pointColor = pow(pointColor, vec3(2.2)); float intensity = pow(s, 10.0 * (1. - 0.5200 + 0.1)); return pointColor * intensity; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = (uv) * vec2(aspectRatio, 1.0);vec3 lastFrameColor = texture(uPingPongTexture, uv).rgb; vec3 lastFrameColorGamma = pow(lastFrameColor, vec3(2.2)); vec3 hsv = rgb2hsv(lastFrameColor); vec3 hsvGamma = rgb2hsv(lastFrameColorGamma); vec2 prevDir = angleToDir(hsv.x); float prevStrength = hsvGamma.z; vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); float blurAmount = 0.03 * prevStrength; uv = uv - prevDir * blurAmount; uv = mix(uv, liquify(uv - prevDir * 0.005, prevDir), (1. - prevStrength) * 0.2500); lastFrameColor = texture(uPingPongTexture, uv).rgb; lastFrameColor = pow(lastFrameColor, vec3(2.2)); int numPoints = int(max(12.0, dist * 24.0)); float speedFactor = clamp(dist, 0.7, 1.3); float radius = mix(0.1, 0.7, 0.5000 * speedFactor); vec3 trailColor = vec3(0.0); int iter = min(numPoints, 24); for (int i = 0; i <= iter; i++) { float t = float(i) / float(numPoints); vec2 interpPos = mix(uPreviousMousePos, uMousePos, t); vec2 prevInterpPos = i > 0 ? mix(uPreviousMousePos, uMousePos, float(i-1) / float(numPoints)) : uPreviousMousePos; trailColor += calculateTrailContribution(interpPos, prevInterpPos, uv, correctedUv, aspectRatio, radius); } trailColor = trailColor / float(min(numPoints, 50) + 1); vec3 blurredLastFrame = vec3(0.0); float clampedDist = clamp(length(trailColor) * dist, 0.0, 1.0); float blurRadius = 0.005; blurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2; blurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(-blurRadius, 0.0)).rgb, vec3(2.2)) * 0.2; blurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, blurRadius)).rgb, vec3(2.2)) * 0.2; blurredLastFrame += pow(texture(uPingPongTexture, uv + vec2(0.0, -blurRadius)).rgb, vec3(2.2)) * 0.2; blurredLastFrame += lastFrameColor * 0.2; vec3 draw = mix(blurredLastFrame, trailColor, clampedDist); draw *= pow(0.5000, 0.2); draw = pow(draw, vec3(1.0/2.2)); fragColor = vec4(draw, 1.0); }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }",
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false }
    }
  ],
  "options": {
    "name": "Logo orb",
    "fps": 60,
    "dpi": 1.5,
    "scale": 1,
    "includeLogo": false,
    "isProduction": false
  },
  "version": "1.4.25",
  "id": "oYOqkoHVH5IVXqLzwGnB"
}
