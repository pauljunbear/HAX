import { render, screen, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import ThreeDEffectsCanvas from './ThreeDEffectsCanvas';

// Mock React Three Fiber components
jest.mock('@react-three/fiber', () => ({
  Canvas: ({ children, ...props }: any) => (
    <div data-testid="r3f-canvas" data-props={JSON.stringify(props)}>
      {children}
    </div>
  ),
  useFrame: jest.fn((callback) => {
    // Simulate frame updates for testing
    setTimeout(() => callback({ delta: 0.016, clock: { elapsedTime: 1 } }, 0.016), 10);
  }),
  useThree: jest.fn(() => ({
    mouse: { x: 0, y: 0 },
    viewport: { width: 800, height: 600 },
    camera: { position: { set: jest.fn() } }
  })),
}));

// Mock drei components
jest.mock('@react-three/drei', () => ({
  OrbitControls: ({ children, ...props }: any) => (
    <div data-testid="orbit-controls" data-props={JSON.stringify(props)}>
      {children}
    </div>
  ),
  PerspectiveCamera: ({ children, ...props }: any) => (
    <div data-testid="perspective-camera" data-props={JSON.stringify(props)}>
      {children}
    </div>
  ),
  useTexture: jest.fn(() => ({
    image: { width: 800, height: 600 },
    needsUpdate: true
  })),
}));

// Mock Three.js
jest.mock('three', () => ({
  ...jest.requireActual('three'),
  MathUtils: {
    lerp: jest.fn((a, b, t) => a + (b - a) * t),
  },
  PlaneGeometry: jest.fn().mockImplementation((width, height) => ({
    width,
    height,
    type: 'PlaneGeometry'
  })),
  BoxGeometry: jest.fn().mockImplementation((width, height, depth) => ({
    width,
    height,
    depth,
    type: 'BoxGeometry'
  })),
}));

// Mock Suspense
jest.mock('react', () => ({
  ...jest.requireActual('react'),
  Suspense: ({ children, fallback }: any) => children || fallback,
}));

describe('ThreeDEffectsCanvas', () => {
  const defaultProps = {
    imageUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
    effectType: '3dPlane' as const,
    visible: true,
    depth: 1,
    rotationSpeed: 1,
    tiltIntensity: 0.2,
    controlsEnabled: true,
    width: 800,
    height: 600,
  };

  // Mock WebGL support by default
  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();
    
    // Mock canvas.getContext to return WebGL context
    HTMLCanvasElement.prototype.getContext = jest.fn((contextType) => {
      if (contextType === 'webgl' || contextType === 'experimental-webgl') {
        return {}; // Mock WebGL context
      }
      return null;
    });
  });

  describe('Component Mounting', () => {
    it('renders 3D canvas when visible and WebGL is supported', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} />);
      
      expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
    });

    it('does not render when visible is false', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} visible={false} />);
      
      expect(screen.queryByTestId('r3f-canvas')).not.toBeInTheDocument();
    });

    it('does not render when imageUrl is not provided', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} imageUrl={undefined} />);
      
      expect(screen.queryByTestId('r3f-canvas')).not.toBeInTheDocument();
    });

    it('applies correct styling and dimensions', () => {
      const { container } = render(<ThreeDEffectsCanvas {...defaultProps} className="custom-class" zIndex={25} />);
      
      const wrapper = container.firstChild as HTMLElement;
      expect(wrapper).toHaveClass('custom-class');
      expect(wrapper).toHaveStyle({ 
        width: '800px',
        height: '600px',
        zIndex: '25'
      });
    });
  });

  describe('WebGL Support Detection', () => {
    it('shows fallback message when WebGL is not supported', () => {
      // Mock no WebGL support
      HTMLCanvasElement.prototype.getContext = jest.fn(() => null);
      
      render(<ThreeDEffectsCanvas {...defaultProps} />);
      
      expect(screen.getByText('3D effects not supported')).toBeInTheDocument();
      expect(screen.getByText('WebGL is required for 3D effects')).toBeInTheDocument();
      expect(screen.queryByTestId('r3f-canvas')).not.toBeInTheDocument();
    });

    it('applies correct styling to fallback component', () => {
      HTMLCanvasElement.prototype.getContext = jest.fn(() => null);
      
      const { container } = render(
        <ThreeDEffectsCanvas {...defaultProps} className="fallback-class" zIndex={30} />
      );
      
      const fallback = container.firstChild as HTMLElement;
      expect(fallback).toHaveClass('fallback-class');
      expect(fallback).toHaveStyle({ 
        width: '800px',
        height: '600px',
        zIndex: '30'
      });
    });
  });

  describe('Effect Types', () => {
    const effectTypes: Array<'3dPlane' | '3dCube' | '3dTilt' | '3dParallax'> = 
      ['3dPlane', '3dCube', '3dTilt', '3dParallax'];

    effectTypes.forEach(effectType => {
      it(`renders ${effectType} effect correctly`, () => {
        render(<ThreeDEffectsCanvas {...defaultProps} effectType={effectType} />);
        
        expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
        
        // Check that the canvas receives the correct props
        const canvas = screen.getByTestId('r3f-canvas');
        const props = JSON.parse(canvas.getAttribute('data-props') || '{}');
        expect(props.camera.position).toEqual([0, 0, 5]);
      });
    });

    it('adjusts orbit controls based on effect type', () => {
      const { rerender } = render(<ThreeDEffectsCanvas {...defaultProps} effectType="3dCube" />);
      
      // For 3dCube, controls should be enabled
      let controls = screen.getByTestId('orbit-controls');
      let controlProps = JSON.parse(controls.getAttribute('data-props') || '{}');
      expect(controlProps.enableZoom).toBe(true);
      expect(controlProps.enableRotate).toBe(true);
      
      // For 3dTilt, controls should be more restricted
      rerender(<ThreeDEffectsCanvas {...defaultProps} effectType="3dTilt" />);
      controls = screen.getByTestId('orbit-controls');
      controlProps = JSON.parse(controls.getAttribute('data-props') || '{}');
      expect(controlProps.enableZoom).toBe(false);
      expect(controlProps.enableRotate).toBe(false);
    });
  });

  describe('Settings and Parameters', () => {
    it('applies depth parameter correctly', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} depth={2.5} />);
      
      expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
      // Depth is passed down to the ImagePlane component internally
    });

    it('applies rotation speed parameter correctly', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} rotationSpeed={2.0} effectType="3dCube" />);
      
      expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
      // Rotation speed affects the cube animation internally
    });

    it('applies tilt intensity parameter correctly', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} tiltIntensity={0.8} effectType="3dTilt" />);
      
      expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
      // Tilt intensity affects mouse-based rotation
    });

    it('disables controls when controlsEnabled is false', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} controlsEnabled={false} />);
      
      expect(screen.queryByTestId('orbit-controls')).not.toBeInTheDocument();
    });
  });

  describe('Canvas Configuration', () => {
    it('configures canvas with correct settings', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} />);
      
      const canvas = screen.getByTestId('r3f-canvas');
      const props = JSON.parse(canvas.getAttribute('data-props') || '{}');
      
      expect(props.camera.position).toEqual([0, 0, 5]);
      expect(props.camera.fov).toBe(75);
      expect(props.gl.alpha).toBe(true);
      expect(props.gl.antialias).toBe(true);
      expect(props.gl.powerPreference).toBe('high-performance');
    });

    it('includes proper lighting setup', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} />);
      
      // Check that lighting components are rendered
      // (This would be tested through the canvas content in a real scenario)
      expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
    });
  });

  describe('Image Texture Loading', () => {
    it('handles image URL prop correctly', async () => {
      const testImageUrl = 'data:image/png;base64,test';
      
      render(<ThreeDEffectsCanvas {...defaultProps} imageUrl={testImageUrl} />);
      
      // Wait for texture loading
      await waitFor(() => {
        expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
      });
      
      // useTexture hook should be called with the image URL
      const { useTexture } = require('@react-three/drei');
      expect(useTexture).toHaveBeenCalledWith(testImageUrl);
    });

    it('handles texture loading errors gracefully', async () => {
      // Mock texture loading error
      const { useTexture } = require('@react-three/drei');
      useTexture.mockImplementationOnce(() => {
        throw new Error('Texture loading failed');
      });
      
      // Component should still render but may show fallback
      expect(() => {
        render(<ThreeDEffectsCanvas {...defaultProps} />);
      }).not.toThrow();
    });
  });

  describe('Performance Considerations', () => {
    it('uses appropriate default dimensions', () => {
      render(<ThreeDEffectsCanvas {...defaultProps} width={undefined} height={undefined} />);
      
      const { container } = render(<ThreeDEffectsCanvas {...defaultProps} />);
      const wrapper = container.firstChild as HTMLElement;
      
      // Should have default dimensions
      expect(wrapper).toHaveStyle({ 
        width: '800px',
        height: '600px'
      });
    });

    it('handles dimension updates correctly', () => {
      const { rerender } = render(<ThreeDEffectsCanvas {...defaultProps} width={400} height={300} />);
      
      let wrapper = document.querySelector('[style*="width: 400px"]');
      expect(wrapper).toBeInTheDocument();
      
      rerender(<ThreeDEffectsCanvas {...defaultProps} width={1200} height={800} />);
      
      wrapper = document.querySelector('[style*="width: 1200px"]');
      expect(wrapper).toBeInTheDocument();
    });
  });

  describe('Accessibility', () => {
    it('provides meaningful content when WebGL is not supported', () => {
      HTMLCanvasElement.prototype.getContext = jest.fn(() => null);
      
      render(<ThreeDEffectsCanvas {...defaultProps} />);
      
      expect(screen.getByText('3D effects not supported')).toBeInTheDocument();
      expect(screen.getByText('WebGL is required for 3D effects')).toBeInTheDocument();
    });

    it('has appropriate styling for fallback state', () => {
      HTMLCanvasElement.prototype.getContext = jest.fn(() => null);
      
      render(<ThreeDEffectsCanvas {...defaultProps} />);
      
      const fallback = screen.getByText('3D effects not supported').parentElement?.parentElement;
      expect(fallback).toHaveClass('flex', 'items-center', 'justify-center');
    });
  });

  describe('Component Lifecycle', () => {
    it('initializes WebGL detection on mount', () => {
      const createElementSpy = jest.spyOn(document, 'createElement');
      
      render(<ThreeDEffectsCanvas {...defaultProps} />);
      
      expect(createElementSpy).toHaveBeenCalledWith('canvas');
    });

    it('handles prop changes correctly', () => {
      const { rerender } = render(<ThreeDEffectsCanvas {...defaultProps} effectType="3dPlane" />);
      
      expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
      
      rerender(<ThreeDEffectsCanvas {...defaultProps} effectType="3dCube" />);
      
      expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
    });

    it('handles visibility toggle correctly', () => {
      const { rerender } = render(<ThreeDEffectsCanvas {...defaultProps} visible={true} />);
      
      expect(screen.getByTestId('r3f-canvas')).toBeInTheDocument();
      
      rerender(<ThreeDEffectsCanvas {...defaultProps} visible={false} />);
      
      expect(screen.queryByTestId('r3f-canvas')).not.toBeInTheDocument();
    });
  });
}); 